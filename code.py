# -*- coding: utf-8 -*-
"""Copy of External data: Local Files, Drive, Sheets, and Cloud Storage

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1oJFuOXtn-iUL0XBFc_vsvLpaoLyM9NUk

This notebook provides recipes for loading and saving data from external sources.

# Local file system

## Uploading files from your local file system

`files.upload` returns a dictionary of the files which were uploaded.
The dictionary is keyed by the file name and values are the data which were uploaded.
"""

from google.colab import files

uploaded = files.upload()

for fn in uploaded.keys():
  print('User uploaded file "{name}" with length {length} bytes'.format(
      name=fn, length=len(uploaded[fn])))

from google.colab import files

uploaded = files.upload()

for fn in uploaded.keys():
  print('User uploaded file "{name}" with length {length} bytes'.format(
      name=fn, length=len(uploaded[fn])))

import numpy as np
import pandas as pd
from sklearn.model_selection import train_test_split
import matplotlib.pyplot as plt 

prediction = 0
prediction1 = 0
weight = np.zeros((10, 785))
y_cap = 0
activation = 0
accuracy = 0
x1 = np.zeros(100) 
y1 = np.zeros(100)
x2 = np.zeros(100) 
y2 = np.zeros(100)

data = np.loadtxt('mnist_data.txt', dtype= int, delimiter = ' ')
label= np.loadtxt('mnist_labels.txt', dtype = int, delimiter = ' ')

a, b = np.shape(data)
c = np.ones((a , 1))
data1 = np.hstack((c, data))

data_train, data_test, y_train, y_test= train_test_split(data1, label, test_size=0.50)

for a in range(100):
  #for training:
  accuracy = 0
  for i in range(0, 5000):
      y_cap = 0
      y_dash = 0
      for j in range(0,10):
          for k in range(0,785):
              activation = activation + weight[j][k] * data_train[i][k]
          if (y_cap < activation):
              y_cap = activation
              y_dash = j
          activation = 0
      if(y_dash != y_train[i]):
          y = y_train[i]
          for j in range(0,785):
              weight[y_dash][j] = weight[y_dash][j] - data_train[i][j]
              weight[y][j] = weight[y][j] + data_train[i][j]
      else:
        accuracy +=1
  print("train accuracy of", a,"accuracy=", (accuracy/5000.0)*100);
  x1[a]=a
  y1[a]=(accuracy/5000.0)*100
  #for testing:
  accuracy = 0
  for i in range(0, 5000):
      y_cap = 0
      y_dash = 0
      for j in range(0,10):
          for k in range(0,785):
              activation = activation + weight[j][k] * data_test[i][k]
          if (y_cap < activation):
              y_cap = activation
              y_dash = j
          activation = 0
      if(y_dash == y_test[i]):
          accuracy += 1
  print("test accuracy of", a,"accuracy=", (accuracy/5000.0)*100);
  x2[a]=a
  y2[a]=(accuracy/5000.0)*100



plt.plot(x1, y1, label = "train")
plt.plot(x2, y2, label = "test")
plt.xlabel('Iteration') 
plt.ylabel('Accuracy') 
plt.show()

